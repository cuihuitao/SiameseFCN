function net = make_branch_matvggm5_nodilation(varargin)
    opts.exemplarSize = [127 127];
    opts.instanceSize = [255 255];
    opts.last_layer = 'conv5_conv';
    
    opts.cudnnWorkspaceLimit = 1024*1024*1024 ; % 1GB
    opts = vl_argparse(opts, varargin) ;

    if numel(opts.exemplarSize) == 1
        opts.exemplarSize = [opts.exemplarSize, opts.exemplarSize];
    end
    if numel(opts.instanceSize) == 1
        opts.instanceSize = [opts.instanceSize, opts.instanceSize];
    end

    net = create_matvggm5(opts);
    
    net = net2last_layer(net, opts.last_layer);
    
    % Check if the receptive field covers full image
    [ideal_exemplar, ~] = ideal_size_dagnn(net, opts.exemplarSize);
    [ideal_instance, ~] = ideal_size_dagnn(net, opts.instanceSize);
    assert(sum(opts.exemplarSize==ideal_exemplar)==2, 'exemplarSize is not ideal.');
    assert(sum(opts.instanceSize==ideal_instance)==2, 'instanceSize is not ideal.');

end

% --------------------------------------------------------------------
function net = create_matvggm5(opts)
    net = dagnn.DagNN();
    lastAdded.var = 'input';
    lastAdded.depth = 3;
    %% conv1 + pool1
    [net, lastAdded] = Conv(net, ...
                            'conv1', 7, 96, lastAdded, opts, ...
                            'relu', true, ...
                            'bias', false, ...
                            'downsample', true);
    [net, lastAdded] = Pool(net, 'conv1', 3, 2, 1, 'max', lastAdded);
    %% conv2 + pool2
    [net, lastAdded] = Conv(net, ...
                            'conv2', 5, 256, lastAdded, opts, ...
                            'relu', true, ...
                            'bias', false, ...
                            'downsample', false);
    % add in 2018/3/8, we found that alex-conv5 has this layer
    % [net, lastAdded] = Pool(net, 'conv2', 3, 1, 1, 'max', lastAdded);
    %% conv3
    [net, lastAdded] = Conv(net, ...
                            'conv3', 3, 512, lastAdded, opts, ...
                            'relu', true, ...
                            'bias', false, ...
                            'downsample', false);
    %% conv4
    [net, lastAdded] = Conv(net, ...
                            'conv4', 3, 512, lastAdded, opts, ...
                            'relu', true, ...
                            'bias', false, ...
                            'downsample', false);   
    %% conv5
    [net, lastAdded] = Conv(net, ...
                            'conv5', 3, 32, lastAdded, opts, ...
                            'relu', true, ...
                            'bias', false, ...
                            'downsample', false); 
    net.initParams() ;
end

function [net, lastAdded] = Conv(net, name, ksize, depth, lastAdded, opts, varargin)
% Helper function to add a Convolutional + BatchNorm + ReLU
% sequence to the network.
  args.relu = true ;
  args.downsample = false ;
  args.bias = false ;
  args = vl_argparse(args, varargin) ;
  if args.downsample, stride = 2 ; else stride = 1 ; end
  if args.bias, pars = {[name '_f'], [name '_b']} ; else pars = {[name '_f']} ; end
  net.addLayer([name  '_conv'], ...
               dagnn.Conv('size', [ksize ksize lastAdded.depth depth], ...
                          'stride', stride, ....
                          'pad', 0, ...
                          'hasBias', args.bias, ...
                          'opts', {'cudnnworkspacelimit', opts.cudnnWorkspaceLimit}), ...
               lastAdded.var, ...
               [name '_conv'], ...
               pars) ;
  net.addLayer([name '_bn'], ...
               dagnn.BatchNorm('numChannels', depth, 'epsilon', 1e-5), ...
               [name '_conv'], ...
               [name '_bn'], ...
               {[name '_bn_w'], [name '_bn_b'], [name '_bn_m']}) ;
  lastAdded.depth = depth ;
  lastAdded.var = [name '_bn'] ;
  if args.relu
    net.addLayer([name '_relu'] , ...
                 dagnn.ReLU(), ...
                 lastAdded.var, ...
                 [name '_relu']) ;
    lastAdded.var = [name '_relu'] ;
  end

end

function [net, lastAdded] = Pool(net, name, ksize, stride, pad, method, lastAdded)
% Helper function to add a Pool
% sequence to the network.
  net.addLayer([name '_pool'], ...
               dagnn.Pooling('poolSize', [ksize ksize], ...
                             'stride', stride, ...
                             'pad', pad,  ...
                             'method', method), ...
               lastAdded.var, ...
               [name '_pool']) ;
  lastAdded.var = [name '_pool'];
end

function net = net2last_layer(net, last_layer)
    layers = net.layers;
    
    index = find(arrayfun(@(l) strcmp(l.name, last_layer), layers));
    for i = length(layers):-1:index+1
        net.removeLayer(layers(i).name)
    end
    
    net.rebuild();
end